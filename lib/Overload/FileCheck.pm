package Overload::FileCheck;

use strict;
use warnings;

# ABSTRACT: override/mock -e demo

BEGIN {

    # VERSION: generated by DZP::OurPkgVersion
    require XSLoader;
    XSLoader::load(__PACKAGE__);
}

# hash for every filecheck we can mock
#   and their corresonding OP_TYPE
my %MAP_FC_OP = (
    'e' => OP_FTIS,
    #'d' => OP_FTDIR,
    # ....
);

# this is saving our custom ops
# optype_id => sub
my $_current_mocks = {};

sub mock_file_check {
    my ( $check, $sub ) = @_;

    die q[Check is not defined] unless defined $check;
    die q[Second arg must be a CODE ref] unless ref $sub eq 'CODE';

    $check =~ s{^-+}{};    # strip any extra dashes
                           #return -1 unless defined $MAP_FC_OP{$check}; # we should not do that
    die qq[Unknown check '$check'] unless defined $MAP_FC_OP{$check};

    my $optype = $MAP_FC_OP{$check};
    die qq[-$check is already mocked by Overload::FileCheck] if exists $_current_mocks->{$optype};

    $_current_mocks->{$optype} = $sub;

    _xs_mock_op($optype);

    return 1;
}

sub unmock_file_check {
    my (@checks) = @_;

    foreach my $check (@checks) {
        die q[Check is not defined] unless defined $check;
        $check =~ s{^-+}{};    # strip any extra dashes
        die qq[Unknown check '$check'] unless defined $MAP_FC_OP{$check};

        my $optype = $MAP_FC_OP{$check};

        delete $_current_mocks->{$optype};

        _xs_unmock_op($optype);
    }

    return 1;
}

# should not be called directly
# this is called from XS to check if one OP is mocked
# and trigger the callback function when mocked

sub _check {
    my ( $optype, $file, @others ) = @_;

    die if scalar @others;    # need to move this in a unit test

    # we have no custom mock at this point
    return FALLBACK_TO_REAL_OP unless defined $_current_mocks->{$optype};

    my ( $out, @extra ) = $_current_mocks->{$optype}->($file);

    return CHECK_IS_FALSE if !$out;
    return FALLBACK_TO_REAL_OP if !ref $out && $out == FALLBACK_TO_REAL_OP;
    return CHECK_IS_TRUE;
}

1;
